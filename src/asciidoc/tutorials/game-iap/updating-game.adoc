= Updating game behavior
:page-slug: game-iap-updating-game
:page-description: Updating our game to respond to payment
:figure-caption!:

In the <<game-assets#,previous section>> of the in-app purchases game tutorial, you DID SOMETHING.
In this section, youâ€™ll
// tag::description[]
DO SOMETHING ELSE.
// end::description[]

By the end of this section, you should feel comfortable:

In this section, we will:

- Add a listener for the `resetLives` event.

- Modify game behavior to reflect the new flow.

- Test the game to make sure everything works correctly.

== Adding a listener for the resetLives event

This template uses CustomEvents to communicate between the game instance and the main component, so we'll respect that in our workflow.

We've already added the `emitEvent(resetLives);` call inside our `onPurchase()` function, so let's add a listener for it!

If you go to `frontend/src/Components/Game/index.js`, you'll find that there are already some listeners defined in the first `useEffect` hook.
This is where we'll define our new one.

`window.addEventListener('resetLives', resetLives);`

Also make sure to remove it inside the `return` function, so that it gets deleted when the game component unmounts.
This is important for preventing memory leaks.

`window.removeEventListener('resetLives', resetLives);`

[source,javascript]
------------------
useEffect(() => {
    if(game){
        game.players = props.players;
    }
}, [props.players])

return (
    <Container>
        <div id={'p5game'} />
        <Loader id={"p5_loading"}><Spinner /> </Loader>
    </Container>
)
------------------

We also need to define the callback function that we're passing to the listener.

[source,javascript]
------------------
...
import { spawnFloatingText } from './Effects/FloatingText';
...

const resetLives = () => {
    game.lives = game.startingLives;
    game.gameOver = false;

    spawnFloatingText("EXTRA LIVES", game.width / 2, game.height / 2, {
        duration: 1,
        maxSize: 45
    });
}
------------------

Here, we do the actual reset of lives.
Additionally, we make sure to reset the `game.gameOver` property to `false` and also spawn some floating text in the middle of the screen to celebrate this wholesome event.

If you've gone through my <<game-intro#,Creating a remixable game>> tutorial or are already familiar with this game template, you could get even more creative and spawn some *exploding particles*!

The player just spent some cash on the game -- they should be rewarded.

== Modifying Block.js

In the original game, once all lives are lost, the game "camera" returns to the bottom.
We don't need this feature, so let's disable it!

Inside `frontend/src/Components/Game/Entities/Block.js`, find the `handleMiss()` function.
It looks like this.

[source,javascript]
------------------
handleMiss() {
    this.hasMissed = true;
    playSound(game.sounds.loselife);

    const distanceFromPreviousBlock = Math.abs(this.pos.x - game.blockDesiredX);
    if (distanceFromPreviousBlock < this.size) {
        this.rotDir = Math.sign(this.pos.x - game.blockDesiredX);
        this.isRotating = true;
    }

    setTimeout(game.loseLife, 400);
    setTimeout(() => {
        if (game.gameOver) {
            moveToStart();
        }
    }, 500);
}
------------------

We want to remove the last part that gets it back to the start, so the final result should look as follows.

[source,javascript]
------------------
handleMiss() {
    this.hasMissed = true;
    playSound(game.sounds.loselife);

    const distanceFromPreviousBlock = Math.abs(this.pos.x - game.blockDesiredX);
    if (distanceFromPreviousBlock < this.size) {
        this.rotDir = Math.sign(this.pos.x - game.blockDesiredX);
        this.isRotating = true;
    }

    setTimeout(game.loseLife, 400);
}
------------------

=== Removing the original Game Over text

Since our new `Game Over` text shows up in a new menu, we don't need the original one where the label would slide down from the top.

We can disable it by going into `frontend/src/Components/setup.js` and, inside the `game.loseGame()` function, removing these two lines.

[source,javascript]
game.ui.instructionsAnimTimer = 0;
game.ui.instructionsFadeOutTimer = game.instructionsFadeOutDuration;

So the whole function should look like this.

[source,javascript]
game.loseGame = () => {
    game.lives = 0;
    game.gameOver = true;
    game.ui.instructionsAnimTimer = 0;
    game.ui.instructionsFadeOutTimer = game.instructionsFadeOutDuration;
    emitEvent('gameOver', { score: game.score });
}

That was all we needed to do acommodate our game to the new way of doing things!

== Testing The Game

To test the new `In-App Purchase` feature, you can use http://developer.withkoji.com/docs/develop/testing-templates#_debugging_in_app_purchases[Koji Debugger] (you'll need to have some balance in your Koji Wallet for this), or you can temporarily disable the payment process and just emit the `resetLives` event directly, as follows.

[source,javascript]
-------------------
const onPurchase = async () => {
    // Comment this for testing, skip the check
    //const purchase = await Koji.iap.startPurchase('extraLives');

    //if (purchase.receiptId) {
        setShowPaymentDialog(false);
        emitEvent('resumeGame');
        emitEvent('resetLives');

        // Submit the score just to have some backup in case
        // the player closes the game before submitting later
        if (dataManager.name !== "") {
            await dataManager.submitScore(score);
        }
    //}
}
-------------------

[NOTE]
Make sure to *uncomment* those lines before publishing.

== Wrapping up

We've finished the main part of our game and set up the In-App Purchase system.

In the <<game-iap-remix#,last section>>, we'll make the price customizable during Remix.

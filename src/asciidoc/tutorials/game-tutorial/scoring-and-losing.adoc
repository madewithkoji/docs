= Scoring and losing
:page-slug: game-scoring-and-losing
:page-description: Adding collision checks and lose conditions
:figure-caption!:

In the <<game-assets#,previous section>> of the remixable game tutorial, you DID SOMETHING.
In this section, youâ€™ll
// tag::description[]
DO SOMETHING ELSE.
// end::description[]

By the end of this section, you should feel comfortable:

In this section, we will:

- Check for a collision between the `Player` and each `Collectible` and add to the game score.

- Add some simple animations.

- Check if a `Collectible` has been missed and take a life away from the player.

== Collision checking

We'll handle collisions in `frontend/src/Components/Game/Entities/Player.js`.

Add a new function to check for collisions and call it from `update()`.

[source,javascript]
-------------------
...
import { CollisionCircle } from '../Utils/Collision'

export default class Player extends Entity {
    ...

    update(){
        ...
        this.checkCollisions();
    }

    checkCollisions() {
        const collectibles = game.findByTag('collectible');

        collectibles.forEach(collectible => {
            if (!collectible.isCollected && CollisionCircle(this, collectible)) {
                collectible.onCollect();
            }
        });
    }
}
-------------------

We also need to define the `onCollect()` function inside `frontend/src/Components/Game/Entities/Collectible.js`.

[source,javascript]
-------------------
...

export default class Collectible extends Entity {
    ...


    onCollect() {
        this.isCollected = true;
    }
}
-------------------

First, we use `game.findByTag('collectible')` to get all our `Collectible` objects.
Then we run through each one, checking if it's colliding with `Player`.

[NOTE]
`game.findByTag(tag: string)` works by filtering the game instance's `entities` array and returns a new array containing all entities with the given tag.

To check for a collision, we use `CollisionCircle()`, which is located in `frontend/src/Components/Game/Utils/Collision.js`.
The function takes two `Entities` as arguments and returns `true` if they are close enough together to collide (based on the size of the entities and their distance apart).

So if Player is colliding with a Collectible and the Collectible in question hasn't already been collected, we trigger the `onCollect()` handler in `Collectible`, which just sets the `isCollected` flag to true.

=== Animated collecting

We could remove our Collectible object now and be done with it, but we don't want this to be just your "run of the mill" tutorial, so let's spice things up a bit!

Instead of the Collectible simply disappearing upon contact, let's have the Player attract it like a magnet and make it explode into particles! That sounds more fun!

Override the `update()` function in `Collectible.js`, but keep the original behavior, which is defined in the parent Entity class.

[source,javascript]
-------------------
// Don't forget the imports!
import { game } from '..'
import Entity from './Entity'
import playSound from '../Utils/playSound'
import { Smooth, Ease, EasingFunctions } from '../Utils/EasingFunctions'
import { spawnParticles } from '../Effects/Particle'
import { spawnFloatingText } from '../Effects/FloatingText'

export default class Collectible extends Entity {
    constructor(x, y, options){
        super(x, y, options);
        ...

        this.animTimer = 0;
    }

    onCollect() {
        this.isCollected = true;
    }

    update(){
        super.update();
        this.handleAnimation();
    }

    handleAnimation() {
        if (!this.isCollected) return;

        this.animTimer += game.delta() * 4;

        this.scale.x = Ease(EasingFunctions.easeInCubic, this.animTimer, 1, -0.95);
        this.scale.y = Ease(EasingFunctions.easeInCubic, this.animTimer, 1, -0.95);

        this.moveTowardsPlayer();

        if (this.animTimer >= 1) this.getCollected();
    }

    moveTowardsPlayer() {
        if (!this.isCollected) return;

        this.velocity.y = Smooth(this.velocity.y, 0, 8);
        this.rotSpeed = Smooth(this.rotSpeed, 0, 8);
        this.pos.x = Smooth(this.pos.x, game.player.pos.x, 12);
        this.pos.y = Smooth(this.pos.y, game.player.pos.y, 12);
    }

    getCollected() {
        this.shouldBeRemoved = true;

        spawnParticles(game.player.pos.x, game.player.pos.y, 10, { img: this.img });

        const x = game.player.pos.x;
        const y = game.player.pos.y - game.player.size * 0.75;

        spawnFloatingText("+1", x, y);
        game.addScore(1)
        playSound(game.sounds.collect);
        game.player.pulse();
    }
}
-------------------

Note that we haven't yet defined the player's `pulse()` function, so the game will crash when there's a collision.
We'll do that next, but first, let's break down this code.

Once we set our `isCollected` value to true, things start to happen.

In `handleAnimation()`, we:

* Advance the `animTimer` property by `game.delta() * 4`.

** Using `game.delta() * 4` means that we want `animTimer` to be incremented by `1` every `0.25` seconds.
The higher the multiplier, the faster we increment it.
[NOTE]
If you're confused by that last statement, here's a more detailed explanation.
Multiplying the delta by a number increments `animTimer` faster according to the multiplier, so game.delta() * 2  increases `animTimer` by 1 in half a second, game.delta() * 4  increases it by 1 in a quarter of a second, and so on.
Internally, `delta()` calls 1 / game.frameRate(), which gives us the time passed since the last frame was rendered. So if you're running at 60 frames per second, 60 * (1 / frameRate()) = 1.

* Use the `animTimer` value to do some `EasingFunctions` and shrink the scale from 1 to 0.05.

** We're not going all the way down to `0`, because that might create some minor glitches, but it doesn't make any difference visually, so a tiny value is fine.

At the same time, in `moveTowardsPlayer()`, we do several things at once.

* `this.velocity.y = Smooth(this.velocity.y, 0, 8)` - Gradually disable the existing vertical velocity.

* `this.rotSpeed = Smooth(this.rotSpeed, 0, 8)` - Start spinning wildly.

* `this.pos.x = Smooth(this.pos.x, game.player.pos.x, 12)`.

* `this.pos.y = Smooth(this.pos.y, game.player.pos.y, 12)` - Quickly move towards the player location.

Once `animTimer` reaches `1` (in about `0.25` seconds, since we're multiplying the delta by `4`), the easing animation will be over, and that's when the actual collecting happens with `getCollected()`.

Finally, in `getCollected()`, we:

* Set the `shouldBeRemoved` flag to `true`.

** This game template already has code that handles removal of entities which have the `shouldBeRemoved` flag set, so that's all we need to do to make it happen.

* Spawn `10` particles at the player's position and give them the same image as the `Collectible`.

* Spawn a `+1` floating text a little above the player.

* Add `1` to the game score.

* Play the `collect` sound.

* Call `game.player.pulse()`, which resets the player's `pulse` animation.

We don't have that animation yet, so let's set it up!

[NOTE]
Remember when we assigned the `game.player` property to the `gameInstance`? We finally make use of it here. Another way to find the player object would be to set the `"player"` tag inside of `Player`, then do something like `const player = game.findByTag('player')[0];`.

Now let's make some more changes to `frontend/src/Components/Game/Entities/Player.js`.

[source,javascript]
-------------------
// Don't forget to import `Ease` and `EasingFunctions`.
import { game } from '..'
import Entity from './Entity'
import { Smooth, Ease, EasingFunctions } from '../Utils/EasingFunctions'
import { CollisionCircle } from '../Utils/Collision'

export default class Player extends Entity {
    constructor(x, y, options){
        super(x, y, options);
        ...

        this.animTimer = 0;
    }

    update(){
        ...
        this.handleAnimation();
    }

    handleAnimation() {
        if (this.animTimer > 1) return;

        this.animTimer += game.delta();

        const intensity = 0.3;
        this.scale.x = Ease(EasingFunctions.easeOutElastic, this.animTimer, 1 + intensity, -intensity);
        this.scale.y = Ease(EasingFunctions.easeOutElastic, this.animTimer, 1 - intensity, +intensity);
    }

    pulse() {
        this.animTimer = 0;
    }
}
-------------------

As you can see, it's similar to the animation setup in `Collectible`.

We increment the `animTimer` property as long as it's below `1`, because our `EasingFunctions` only work for values between `0` and `1`.

Then we modify the scale again, but this time we're using the `easeOutElastic` function, which gives us a nice bouncy effect.

The `pulse()` function just resets the `animTimer` to `0`, which restarts the animation.

image:https://i.imgur.com/EcVO5ZU.gif[alt="screenshot player"]

Now it's looking better!

== Checking for missed collectibles

We need a way to lose the game, too!

To do that, we have to check if any of the collectibles went past the player and off the screen.

Let's go back to `frontend/src/Components/Game/Entities/Collectible.js` and add that check.

[source,javascript]
-------------------
import { game } from '..'
...

export default class Collectible extends Entity {
    ...

    update(){
        ...
        this.checkIfMissed();
    }

    checkIfMissed() {
        if (game.gameOver) return;

        const isBelowScreen = this.pos.y > game.height + this.size / 2;
        if (isBelowScreen) this.onMiss();
    }

    onMiss() {
        game.loseLife();
        playSound(game.sounds.loselife);
        game.camera.shake(0.25, 12);
        this.shouldBeRemoved = true;
    }
}
-------------------

First, we check the Collectible's `pos.y` coordinate, and if it's higher than the lower edge of the screen, we trigger the `onMiss()` function. In `onMiss()`, we:

* Trigger a `game.loseLife` function.

** The template makes sure that the game automatically ends when there are no lives left.

* Play a `loselife` sound.

* Shake the camera a bit to amplify the negative effect.

* Set the `shouldBeRemoved` flag to `true`, so that our object will be deleted from memory in the next frame.

image:https://i.imgur.com/ptLizkT.gif[alt="screenshot player"]

[NOTE]
Deleting unused objects from memory is an especially important step in every game in order to prevent memory leaks, which can result in performance slowdown and eventually a crash.

== Wrapping up

Our game is now playable!

In the <<game-managing-difficulty#,next section>>, we'll add some difficulty management, so that the game gets progressively harder as it's played.

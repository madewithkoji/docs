= Creating game objects
:page-slug: game-tutorial-creating-game-objects
:page-description: Creating game objects
:figure-caption!:

In this section, we will:

- Define our `Player` and `Collectible` classes.

- Create controls for the `Player`.

- Spawn `Player` into the game.

- Create a spawning system for Collectibles.

== Player

This template uses an https://en.wikipedia.org/wiki/Entity_component_system[Entity] system, so we can extend the base `Entity` class from our template to define the game objects.

[NOTE]
This template already has an example `Player` class defined, so there's no need to create a new file.
We can use that!

Let's go to `Player.js` inside the `frontend/src/Components/Game/Entities` folder.

Modify the constructor to use the image and size that we defined in the previous section.

[source,javascript]
-------------------
import { game } from '..'
import Entity from './Entity'

export default class Player extends Entity {
    constructor(x, y, options) {
        super(x, y, options);
        
        this.img = game.images.player;
        this.size = game.playerSize;
    }

    update(){

    }
}
-------------------

[NOTE]
Make sure you clear the `update()` function in case there's any example code in it.
We'll modify it later.

That's all we need to do to make our `Player` object ready to be drawn on the screen! Now we just need to instantiate it.

=== Adding Player to the game

Head over to `frontend/src/Components/Game/setup.js`, where you'll find the `init()` function.
Clear everything inside it, and change it to:

[source,javascript]
-------------------
import { game } from "."
import Player from './Entities/Player'

...

const init = () => {
    const x = game.width / 2;
    const y = game.height - 160;
    const player = new Player(x, y);
    game.addEntity(player);
    game.player = player;
}
-------------------

Here, we:

- Instantiate a new `Player` object to the center-bottom of the screen.

- Add it to the game.

- Assign it directly to the `game` instance so we can easily access it later by calling `game.player`.

This will make our code a bit cleaner.

If you take a look at the game preview and click on the *Play* button, you'll see our player near the bottom of the screen.

image:https://i.imgur.com/jynK73v.png[]

Awesome!

=== Adding movement to Player

At the moment, our player is static.
Let's change that!

Go back to `frontend/src/Components/Game/Entities/Player.js`.

We'll define a new function called `handleControls()` to handle player movement, and put it inside `update()`, which runs every frame.

[source,javascript]
----
// Don't forget the imports!
import { game } from '..';
import Entity from './Entity'
import { Smooth } from '../Utils/EasingFunctions'
...
update(){
    this.handleControls();
}

handleControls(){
    if(!game.isTouching) return; // Do nothing if we're not touching or clicking

    this.pos.x = Smooth(this.pos.x, game.mouseX, 13);
}
----

We use the `Smooth` function from `Game/Utils/EasingFunctions.js` to move the player smoothly to its goal, which is our `game.mouseX` touch coordinate.
The number parameter at the end determines how quickly that happens.
The higher it is, the slower the player will move.
Feel free to experiment with different numbers.

If you try the game now, the player should move left or right when we touch or click on the screen.

It works, but let's make it prettier!

What if the player tilted slightly in the direction it's moving? We also don't want to move outside of the screen for any reason.

Let's add those features to our `Player` class.

[source,javascript]
-------------------
import { game } from '..';
import Entity from './Entity'
import { Smooth } from '../Utils/EasingFunctions'
...
export default class Player extends Entity {
    constructor(x, y, options) {
        ...
        this.goalRotation = 0;
    }
}

update(){
    this.handleControls();

    this.rotation = Smooth(this.rotation, this.goalRotation, 8);
}

handleControls(){
    if(game.isTouching){
        this.pos.x = Smooth(this.pos.x, game.mouseX, 13);
        this.keepInsideScreen();

        const isTouchingFarEnough = Math.abs(this.pos.x - game.mouseX) > this.size / 2;

        if (isTouchingFarEnough) {
            const movingDirection = Math.sign(game.mouseX - this.pos.x);
            this.goalRotation = movingDirection * game.radians(15);
        }else{
            this.goalRotation = 0;
        }
    }else{
        this.goalRotation = 0;
    }
}

keepInsideScreen() {
    const limitLeft = this.size / 2;
    const limitRight = game.width - this.size / 2;
    this.pos.x = game.constrain(this.pos.x, limitLeft, limitRight);
}
-------------------

With `keepInsideScreen()`, we constrain the player's `x` coordinate so it doesn't overlap or go outside the screen boundaries.

Then we check to see if we're touching outside of the player, in which case we're setting `goalRotation` slightly to that side.

image:https://i.imgur.com/ELLEfka.gif[]

Looking good so far!


== Collectible

We have the player.
Now we need something to collect!

Create a `Collectible.js` file in the `frontend/src/Components/Game/Entities` folder, and add the following contents.

[source,javascript]
-------------------
import { game } from '..'
import Entity from './Entity'

export default class Collectible extends Entity {
    constructor(x, y, options) {
        super(x, y, options);
        
        this.img = game.images.collectible;
        this.size = game.random(game.collectibleSizeMin, game.collectibleSizeMax);
        this.tag = "collectible";
        this.velocity.y = game.random(game.speedMin, game.speedMax);
        this.rotSpeed = game.random(-0.03, 0.03);
        this.isCollected = false;
    }
}
-------------------

Notice we're using some properties that haven't been defined yet.
Let's head back to `frontend/src/Components/Game/preload.js` and add the properties to `initializeValues()`.

[source,javascript]
-------------------
...
const initializeValues = () => {
    ...
    game.speedMin = 2;
    game.speedMax = 4;
    game.collectibleSizeMin = isMobile() ? 55 : 85;
    game.collectibleSizeMax = isMobile() ? 75 : 105;
}
-------------------

Let's break down what we're doing in that constructor.

`this.img = game.images.collectible` - Sets the image for the object to the previously loaded `Collectible` image.

`this.size = game.random(game.collectibleSizeMin, game.collectibleSizeMax)` - Sets the size of the image to a random value between `game.collectibleSizeMin` and `game.collectibleSizeMax`.

`this.tag = "collectible"`` - Sets the tag, so we can find it later using `game.findByTag()`.

`this.velocity.y = game.random(game.speedMin, game.speedMax)` - Sets the vertical velocity to a random value between `game.speedMin` and `game.speedMax`.

`this.rotSpeed = game.random(-0.03, 0.03)` - Sets the rotation speed to a random value between `-0.03` and `0.03`.

`this.isCollected = false` - Defines a boolean property to track whether or not the object has been collected, and set it to false.

The `Entity` class handles the movement of objects based on its `velocity` property.
Since we already set the velocity in the `Collectible` constructor, that's all we need to do to make our Collectibles fall down indefinitely!

Now let's try spawning some!

=== Spawning Collectibles

Collectibles need to spawn throughout the game, not just in the beginning like the Player does.
We handle that inside `frontend/src/Components/Game/draw.js`.
Every function placed here will run with each game frame.

Add a `manageSpawn()` function to handle the spawning logic and call it inside `draw()`.
We also need a spawnCollectible() function to add new Collectibles to the game.

[source,javascript]
----
...
import Collectible from './Entities/Collectible'

const draw = () => {
    ...
    manageSpawn();
}

const manageSpawn = () => {
    game.spawnTimer -= game.delta();

    if (game.spawnTimer <= 0) {
        spawnCollectible();
        game.spawnTimer = game.random(game.spawnPeriodMin, game.spawnPeriodMax);
    }
}

const spawnCollectible = () => {
    const x = game.random(0, game.width);
    const y = -game.collectibleSizeMax;
    game.addEntity(new Collectible(x, y));
}
----

If we save our changes now, we won't see any falling objects and the program might crash, because we haven't properly initialized `spawnPeriodMin`, `spawnPeriodMax` and `spawnTimer`.

So, go back to `frontend/src/Components/Game/preload.js`, and add the following lines to `initializeValues()`.

[source,javascript]
----
...
const initializeValues = () => {
    ...
    game.spawnPeriodMin = 1.5; // Time in seconds
    game.spawnPeriodMax = 2; // Time in seconds
    game.spawnTimer = 0.1;
}
----

[NOTE]
Sometimes, after compile errors have been resolved, you might need to reload your live preview manually for everything to work correctly again.

Let's break down that spawn function.

* Every frame, we decrease `game.spawnTimer` by `game.delta()`.

** `game.delta()` is a helper function that's basically a shortcut for calling `1.0 / game.frameRate()`, which represents the time since the last frame was rendered.
It allows us to do time-based increments.

* When the timer reaches `0`, we spawn a new collectible at a random point above the screen and reset the timer to a random value between `game.spawnPeriodMin` and `game.spawnPeriodMin`.

If you start the game now, you'll see a bunch of donuts appearing every `1.5` to `2` seconds and falling to the bottom.

image:https://i.imgur.com/mtzJFG2.gif[]

== Wrapping up

Now that we've created the `Player` and `Collectible` objects and spawned them, we need to give them the ability to interact.

In the <<game-tutorial-scoring-and-losing#,next section>>, we check for collisions between the Player and Collectibles and add to the score every time a collision happens.
If a Collectible falls to the bottom without getting caught, we take a life away from the Player.
When the Player loses three lives, the game ends.
= Migrating to the Koji core package
:page-slug: migrate-koji-core
:page-description: Guide for migrating Koji templates that use deprecated packages to the Koji core package.

The <<withkoji-koji-core#, @withkoji/core package>> includes everything you need to access platform services in your Kojis.
It requires less boilerplate code and provides more flexibility than the packages it replaces.
If your Koji code uses any of the <<packages-overview#_deprecated_packages,deprecated packages>>, follow this guide to migrate to the @withkoji/core package.
////
what's diff

custom data no longer relies on VCCs in JSON customization file with specific format
Manage remix data with greater flexibility, without the need for specialized JSON customization files.
getting, storing, and capturing data works is that everything is now dynamic and decoupled from json-defined editor types.

recommend single configuration file, initialized once in each service

scoped for frontend or backend services

TIP: For a mapping of all deprecated packages to the replacement functionality in @withkoji/core, see <<_package_comparison_reference>>.
////

== Migrating configuration data

The @withkoji/core package must be initialized with configuration data that creates a service map and sets up remixing and other platform services in your Koji.
In Kojis that use the deprecated packages, this configuration data is typically maintained across multiple JSON files in the `.koji` directory of the project.

To simplify implementation of the @withkoji/core package, it is recommended that all configuration data is defined in a single `koji.json` file at the root of the project.
This pattern also reduces code dependencies, such as those used to patch together files, and follows good application development practices, such as https://12factor.net/config[12 Factor App Development].

. At the root of the project, create a new file called `koji.json`.
. Migrate the configuration data from the `.koji` directory to the following keys in the `koji.json` file.
* `develop` – Development instructions from `.koji/project/develop.json`.
* `deploy` – Deployment instructions from `.koji/project/deploy.json`.
* `remixData` – Default values for remix data from the scope section of any JSON customization files in the `.koji/customization` directory.
+
NOTE: With the @withkoji/core package, you no longer need specialized JSON customization files to configure Visual Customization Controls (VCCs).
For more information on managing remix data, see <<_getting_and_setting_remix_data>>.

* `@@initialTransform` – Placeholder values for new remixes from the `@@initialTransform` key of any JSON customization files in the `.koji/customization` directory.
* `entitlements` – Entitlements from the `.koji/project/entitlements.json` file.

+
.Example of a `koji.json` file
[source,JSON]
----
include::../_includes/koji.json[]
----

. After you have migrated the data from the JSON files, you can safely remove the `.koji` directory.

== Migrating frontend features

After you finish migrating the configuration data, you can start updating your code to use the @withkoji/core package.

. Install the @withkoji/core package in the frontend.
+
[source, Bash]
npm install @withkoji/core

. Import the package in your frontend code.
+
[source,Javascript]
import Koji from '@withkoji/core';

. Use the `Koji.config` function to initialize the package with your configuration data.
+
Ideally, your code will initialize the package one time, before any data in the application is rendered.
For example:
+
[source,Javascript]
----
// Initialize
Koji.config(require('././koji.json'));

// render
render();
----

. Replace functionality from the deprecated packages with methods in the @withkoji/core package.
+
The replacement methods vary depending on which packages and functionality you have implemented in your code.
Key changes include:

* Custom remix data no longer relies on VCC definitions in JSON files.
Instead, the methods of capturing and storing data are decoupled from one another and can be explicitly controlled in your code.
See <<_getting_and_setting_remix_data>>.
* Detecting the current context no longer relies on URL query parameters.
Instead, the context is available as a frontend property.
See <<_context>>.
* Dispatch no longer requires a constructor, and the `connect` method is promised-based.
See <<_dispatch_on_the_frontend>>.

+
For a comprehensive mapping of deprecated packages to the replacement functionality in @withkoji/core, see the <<_package_comparison_reference>>.
. After you have implemented all frontend functionality with the @withkoji/core package, you can remove the deprecated packages.
For example:
+
[source, Bash]
npm remove @withkoji/auth @withkoji/dispatch @withkoji/iap @withkoji/vcc

== Migrating backend features


== Package comparison reference

=== @withkoji/analytics

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

| track
| frontend/analytics track
|===

=== @withkoji/auth

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

|
|
|===

=== @withkoji/database

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

|
|
|===

=== @withkoji/dispatch

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

| authToken
| ???

| clientId
| ???

| connectedClients
| ???

| latency
| ???

| shardName
| ???

| userInfo
| ???

| connect
| frontend/dispatch
See <<_dispatch_on_the_frontend>>.

backend/dispatch
See <<_dispatch_on_the_backend>>.

| disconnect
| frontend/dispatch
See <<_dispatch_on_the_frontend>>.

backend/dispatch

| emitEvent
| frontend/dispatch

backend/dispatch
See <<_dispatch_on_the_backend>>.

| identify
| frontend/dispatch

backend/dispatch

| info
| frontend/dispatch

backend/dispatch

| on
| frontend/dispatch
See <<_dispatch_on_the_frontend>>.

backend/dispatch

| removeEventListener
| frontend/dispatch

backend/dispatch

| setUserInfo
| frontend/dispatch

backend/dispatch
|===

==== Dispatch on the frontend

Implementing real-time dispatch in a frontend service works similarly in @withkoji/core to how it worked in the deprecated packages.
However, you no longer need to initialize it with a constructor.
Also, the `connect` method is promise-based, so you can await the result before setting up listeners.
For example:

[source,JavaScript]
----
const connection = await Koji.dispatch.connect();

console.log(connection); // Connection deatils

Koji.dispatch.on('message', (payload) => doSomething(payload));

Koji.dispatch.disconnect();
----

==== Dispatch on the backend

Implementing real-time dispatch in a backend service works similarly in @withkoji/core to how it worked in the deprecated packages.
For example:

[source,JavaScript]
----
...
app.get('/dispatch-event', async (req, res) => {
  const dispatch = new KojiBackend.Dispatch({ res });

  // Wait for a connection (`connection` will have information about the connection)
  const connection = await dispatch.connect({});

  // Send a message to all connected users (in the scope of the template/remix)
  dispatch.emitEvent('test', { hello: 'world' });

  res.status(200).json({
    messageSent: true,
  });
});
...
----

=== @withkoji/iap

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

|
|
|===

=== @withkoji/user-defaults

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

|
|
|===

=== @withkoji/vcc

include::../_includes/deprecationQR.adoc[tag=all]

[cols="2*a", options=header]
|===
| Deprecated package
| @withkoji/core

2+|
==== FeedSdk

| context
| frontend/playerState See <<_context>>.

| createRemix
| ???

| load
| ???

| navigate
| ???

| onPlaybackStateChanged
| ???

| present
| ???

| requestCancelTouch
| ???

| share
| ???

2+|
==== InstantRemixing

| finish
| frontend/remix See <<_getting_and_setting_remix_data>>.

| get(['scope', 'key']) // customization values
| frontend/remix See <<_getting_and_setting_remix_data>>.

| get(['metadata', 'projectId']) // project metadata
| ???

| get(['serviceMap', 'backend']) // service endpoints

| frontend/serviceMap
See <<_services>>.

| onPresentControl
| frontend/ui See <<_getting_and_setting_remix_data>>.

| onSetActivePath
| ???

| onSetCurrentState
| ???

| onSetRemixing
| frontend/playerState See <<_remix_state>>.

| onSetValue
| frontend/remix See <<_getting_and_setting_remix_data>>.

| onValueChanged
| frontend/remix See <<_getting_and_setting_remix_data>>.

| ready
| frontend/Koji

2+|
==== Keystore

| generateSignedUrl
| frontend/remix See <<_secrets>>.

| resolveValue
| frontend/remix, backend/secret See <<_secrets>>.
|===

==== Context
A Koji can provide different experiences for different situations, or "contexts."
For example, you might provide a different experience during a remix than when the template is running.
Or, you might provide an admin experience with tools that are only available for the creator of the Koji.

To detect the current context with the deprecated packages, you would parse the URL for a query parameter.
In the @withkoji/core package, the context is available from `Koji.playerState`.
For example:

[source,Javascript]
----
const { context, receiptType } = Koji.playerState;

// Possible context values: 'about' | 'admin' | 'remix' | 'sticker' | 'receipt' | 'screenshot' | 'default'

// Possible receiptType values: 'buyer' | 'seller'
----

==== Remix state

To listen for changes in remix state, use `Koji.playerState`.
This method works similarly to `.onSetRemixing` in the deprecated package.

[source,Javascript]
----
const unsubscribe = Koji.playerState.subscribe((isRemixing, editorAttributes) => {
  setSomeState(isRemixing);
  // Change Koji experience
});

// To remove listeners on unmount etc.
unsubscribe();
----

==== Getting and setting remix data

One of the biggest advantages of the @withkoji/core package is that you can manage custom remix date with greater flexibility.
You no longer need specialized JSON customization files to configure VCCs.
Instead, you configure only the initial values for remix data.
Then, your application code can control when and how to capture and store data from users.
For example, you can maintain the state locally and store the remix data right before advancing to the preview.

To retrieve initial values with the deprecated package, you would specify the scope and key from one of your VCC files.
For example:

[source,Javascript]
const backgroundColor = instantRemixing.get(['general', 'backgroundColor']);

In @withkoji/core, all of the initial remix data is available as an object.
For example:

[source,Javascript]
----
import Koji from '@withkoji/core';

const remixData = Koji.remix.get();

const { backgroundColor } = remixData;
----

To manage remix data with the deprecated package, you would use methods such as `onSetValue`, `onValueChanged`, and `onPresentControl`.

In @withkoji/core, the methods of capturing and storing data are decoupled from one another and can be explicitly controlled in your code.
The following example uses `capture` to accept an image input from a user, and then `set` to update the value in the `remixData` object.

[source,Javascript]
----
const imageURL = await Koji.ui.capture.image();

Koji.remix.set({ backgroundImage: imageURL });
----

The `set` method works similarly to `setState` in React.
It will intelligently merge your remixData behind the scenes.
For example:

[source,Javascript]
----
const data = Koji.remix.get(); // { textColor: '#000000' }

Koji.remix.set({ backgroundImage: 'https://myImage.com/hello.jpg' });

const newData = Koji.remix.get(); // { textColor: '#000000',  backgroundImage: 'https://myImage.com/hello.jpg' }
----

If you need to explicitly set the entire object, you can use `overwrite`.
For example:

[source,Javascript]
----
Koji.remix.overwrite({
  backgroundImage: 'someValue',
  textColor: '#000000',
});
----

When you are ready to advance to the preview, you can set your updated data, wait for the platform to confirm that the data has been saved, and advance the view.
For example:

[source,Javascript]
----
const onFinish = async () => {
  await Koji.remix.set({
    ...this.state, // Just an example where the state reflects remixData
  });

  Koji.remix.finish();
};
----

==== Services

If your Koji uses a backend service, you would use `instantRemixing.get` in the deprecated package to retrieve the endpoint.
For example:

[source,Javascript]
const backendURL = instantRemixing.get(['serviceMap', 'backend']);

In @withkoji/core, the service endpoints are available on the `services` property.
For example:

[source,Javascript]
const backendURL = Koji.services.backend

==== Secrets

To save sensitive data that isn't visible to users by default and isn't copied when someone forks or remixes a template, you can use the `encryptValue` method.
If anyone were to examine the remixData from a remix of the following example, only the `encryptedValue` would be visible.

[source,Javascript]
----
const storeSecretImage = async () => {
  // Capture an image (e.g., https://images.koji-cdn.com/my-image.png)
  const image = await Koji.ui.capture.image();

  // Make sure the user has chosen an image
  if (!image) return;

  // Get an encrypted value (e.g., $secret_xyz)
  const encryptedValue = await Koji.remix.encryptValue(image);

  // Store the value
  await Koji.remix.set({ secretImage: encryptedValue });
};
----

To retrieve the value, use the `KojiBackend.Secret` module to securely resolve it.
For example:

[source,Javascript]
----
...
import kojiConfig from '../../koji.json';

// Create server
const app = express();

// Koji Middleware
app.use(KojiBackend.middleware(kojiConfig));

app.post('/resolve-secret', async (req, res, next) => {
  // Init
  const secret = new KojiBackend.Secret({ res });

  // Pass the encrypted value in the request body
  const decryptedValue = await secret.resolveValue(req.body.encryptedValue);

  // Pass back the decrypted value (https://images.koji-cdn.com/my-image.png)
  res.status(200).json({
    decryptedValue,
  });
});
----
